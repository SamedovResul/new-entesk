{"ast":null,"code":"export const SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nexport const ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nexport function getPlacementData(_ref) {\n  let {\n    anchorRect: p,\n    popperSize: c,\n    arrowSize: f,\n    arrowOffset: l = 0,\n    side: d,\n    sideOffset: h = 0,\n    align: x,\n    alignOffset: g = 0,\n    shouldAvoidCollisions: u = !0,\n    collisionBoundariesRect: w,\n    collisionTolerance: m = 0\n  } = _ref;\n  if (!p || !c || !w) return {\n    popperStyles: o,\n    arrowStyles: n\n  };\n\n  const y = function (e, r) {\n    let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let i = arguments.length > 4 ? arguments[4] : undefined;\n    const p = i ? i.height : 0,\n          a = t(r, e, \"x\"),\n          s = t(r, e, \"y\"),\n          c = s.before - o - p,\n          f = s.after + o + p,\n          l = a.before - o - p,\n          d = a.after + o + p;\n    return {\n      top: {\n        start: {\n          x: a.start + n,\n          y: c\n        },\n        center: {\n          x: a.center,\n          y: c\n        },\n        end: {\n          x: a.end - n,\n          y: c\n        }\n      },\n      right: {\n        start: {\n          x: d,\n          y: s.start + n\n        },\n        center: {\n          x: d,\n          y: s.center\n        },\n        end: {\n          x: d,\n          y: s.end - n\n        }\n      },\n      bottom: {\n        start: {\n          x: a.start + n,\n          y: f\n        },\n        center: {\n          x: a.center,\n          y: f\n        },\n        end: {\n          x: a.end - n,\n          y: f\n        }\n      },\n      left: {\n        start: {\n          x: l,\n          y: s.start + n\n        },\n        center: {\n          x: l,\n          y: s.center\n        },\n        end: {\n          x: l,\n          y: s.end - n\n        }\n      }\n    };\n  }(c, p, h, g, f),\n        b = y[d][x];\n\n  if (!1 === u) {\n    const t = e(b);\n    let o = n;\n    f && (o = i({\n      popperSize: c,\n      arrowSize: f,\n      arrowOffset: l,\n      side: d,\n      align: x\n    }));\n    return {\n      popperStyles: { ...t,\n        \"--radix-popper-transform-origin\": r(c, d, x, l, f)\n      },\n      arrowStyles: o,\n      placedSide: d,\n      placedAlign: x\n    };\n  }\n\n  const S = DOMRect.fromRect({ ...c,\n    ...b\n  }),\n        $ = (O = w, z = m, DOMRect.fromRect({\n    width: O.width - 2 * z,\n    height: O.height - 2 * z,\n    x: O.left + z,\n    y: O.top + z\n  }));\n  var O, z;\n\n  const R = s(S, $),\n        M = y[a(d)][x],\n        D = function (t, e, r) {\n    const o = a(t);\n    return e[t] && !r[o] ? o : t;\n  }(d, R, s(DOMRect.fromRect({ ...c,\n    ...M\n  }), $)),\n        A = function (t, e, r, o, n) {\n    const i = \"top\" === r || \"bottom\" === r,\n          p = i ? \"left\" : \"top\",\n          a = i ? \"right\" : \"bottom\",\n          s = i ? \"width\" : \"height\",\n          c = e[s] > t[s];\n    if ((\"start\" === o || \"center\" === o) && (n[p] && c || n[a] && !c)) return \"end\";\n    if ((\"end\" === o || \"center\" === o) && (n[a] && c || n[p] && !c)) return \"start\";\n    return o;\n  }(c, p, d, x, R),\n        I = e(y[D][A]);\n\n  let C = n;\n  f && (C = i({\n    popperSize: c,\n    arrowSize: f,\n    arrowOffset: l,\n    side: D,\n    align: A\n  }));\n  return {\n    popperStyles: { ...I,\n      \"--radix-popper-transform-origin\": r(c, D, A, l, f)\n    },\n    arrowStyles: C,\n    placedSide: D,\n    placedAlign: A\n  };\n}\n\nfunction t(t, e, r) {\n  const o = t[\"x\" === r ? \"left\" : \"top\"],\n        n = \"x\" === r ? \"width\" : \"height\",\n        i = t[n],\n        p = e[n];\n  return {\n    before: o - p,\n    start: o,\n    center: o + (i - p) / 2,\n    end: o + i - p,\n    after: o + i\n  };\n}\n\nfunction e(t) {\n  return {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    minWidth: \"max-content\",\n    willChange: \"transform\",\n    transform: `translate3d(${Math.round(t.x + window.scrollX)}px, ${Math.round(t.y + window.scrollY)}px, 0)`\n  };\n}\n\nfunction r(t, e, r, o, n) {\n  const i = \"top\" === e || \"bottom\" === e,\n        p = n ? n.width : 0,\n        a = n ? n.height : 0,\n        s = p / 2 + o;\n  let c = \"\",\n      f = \"\";\n  return i ? (c = {\n    start: `${s}px`,\n    center: \"center\",\n    end: t.width - s + \"px\"\n  }[r], f = \"top\" === e ? `${t.height + a}px` : -a + \"px\") : (c = \"left\" === e ? `${t.width + a}px` : -a + \"px\", f = {\n    start: `${s}px`,\n    center: \"center\",\n    end: t.height - s + \"px\"\n  }[r]), `${c} ${f}`;\n}\n\nconst o = {\n  position: \"fixed\",\n  top: 0,\n  left: 0,\n  opacity: 0,\n  transform: \"translate3d(0, -200%, 0)\"\n},\n      n = {\n  position: \"absolute\",\n  opacity: 0\n};\n\nfunction i(_ref2) {\n  let {\n    popperSize: t,\n    arrowSize: e,\n    arrowOffset: r,\n    side: o,\n    align: n\n  } = _ref2;\n  const i = (t.width - e.width) / 2,\n        a = (t.height - e.width) / 2,\n        s = {\n    top: 0,\n    right: 90,\n    bottom: 180,\n    left: -90\n  }[o],\n        c = Math.max(e.width, e.height),\n        f = {\n    width: `${c}px`,\n    height: `${c}px`,\n    transform: `rotate(${s}deg)`,\n    willChange: \"transform\",\n    position: \"absolute\",\n    [o]: \"100%\",\n    direction: p(o, n)\n  };\n  return \"top\" !== o && \"bottom\" !== o || (\"start\" === n && (f.left = `${r}px`), \"center\" === n && (f.left = `${i}px`), \"end\" === n && (f.right = `${r}px`)), \"left\" !== o && \"right\" !== o || (\"start\" === n && (f.top = `${r}px`), \"center\" === n && (f.top = `${a}px`), \"end\" === n && (f.bottom = `${r}px`)), f;\n}\n\nfunction p(t, e) {\n  return (\"top\" !== t && \"right\" !== t || \"end\" !== e) && (\"bottom\" !== t && \"left\" !== t || \"end\" === e) ? \"ltr\" : \"rtl\";\n}\n\nfunction a(t) {\n  return {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\"\n  }[t];\n}\n\nfunction s(t, e) {\n  return {\n    top: t.top < e.top,\n    right: t.right > e.right,\n    bottom: t.bottom > e.bottom,\n    left: t.left < e.left\n  };\n}","map":{"version":3,"sources":["packages/core/popper/src/popper.ts"],"names":["SIDE_OPTIONS","ALIGN_OPTIONS","getPlacementData","anchorRect","popperSize","arrowSize","arrowOffset","side","sideOffset","align","alignOffset","shouldAvoidCollisions","collisionBoundariesRect","collisionTolerance","popperStyles","UNMEASURED_POPPER_STYLES","arrowStyles","UNMEASURED_ARROW_STYLES","allPlacementPoints","getAllPlacementPoints","popperPoint","getPlacementStylesForPoint","getPopperArrowStyles","getTransformOrigin","placedSide","placedAlign","popperRect","DOMRect","fromRect","collisionBoundariesRectWithTolerance","popperCollisions","getCollisions","getOppositeSide","oppositeSidePopperPoint","getSideAccountingForCollisions","getAlignAccountingForCollisions","arrowBaseToTipLength","height","x","getPopperSlotsForAxis","y","topY","before","bottomY","after","leftX","rightX","top","start","center","end","right","bottom","left","axis","anchorStart","dimension","anchorDimension","popperDimension","collisions","oppositeSideCollisions","oppositeSide","anchorSize","isHorizontalSide","startBound","endBound","isAnchorBigger","point","Math","round","window","scrollX","scrollY","position","minWidth","willChange","transform","arrowBaseLength","width","opacity","popperCenterX","popperCenterY","rotation","arrowMaxDimension","max","styles","direction","getArrowCssDirection","rect","amount"],"mappings":"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","sourcesContent":["import * as CSS from 'csstype';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Axis = 'x' | 'y';\ntype Side = typeof SIDE_OPTIONS[number];\ntype Align = typeof ALIGN_OPTIONS[number];\ntype Point = { x: number; y: number };\ntype Size = { width: number; height: number };\n\ntype GetPlacementDataOptions = {\n  /** The rect of the anchor we are placing around */\n  anchorRect?: ClientRect;\n  /** The size of the popper to place */\n  popperSize?: Size;\n  /** An optional arrow size */\n  arrowSize?: Size;\n  /** An optional arrow offset (along the side, default: 0) */\n  arrowOffset?: number;\n  /** The desired side */\n  side: Side;\n  /** An optional side offset (distance from the side, default: 0)  */\n  sideOffset?: number;\n  /** The desired alignment */\n  align: Align;\n  /** An optional alignment offset (distance along the side, default: 0) */\n  alignOffset?: number;\n  /** An option to turn on/off the collision handling (default: true) */\n  shouldAvoidCollisions?: boolean;\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect?: ClientRect;\n  /** The tolerance used for collisions, ie. if we want them to trigger a bit earlier (default: 0) */\n  collisionTolerance?: number;\n};\n\ntype PlacementData = {\n  popperStyles: CSS.Properties;\n  arrowStyles: CSS.Properties;\n  placedSide?: Side;\n  placedAlign?: Align;\n};\n\n/**\n * Given all the information necessary to compute it,\n * this function calculates all the necessary placement data.\n *\n * It will return:\n *\n * - the styles to apply to the popper (including a custom property that is useful to set the transform origin in the right place)\n * - the styles to apply to the arrow\n * - the placed side (because it might have changed because of collisions)\n * - the placed align (because it might have changed because of collisions)\n */\nfunction getPlacementData({\n  anchorRect,\n  popperSize,\n  arrowSize,\n  arrowOffset = 0,\n  side,\n  sideOffset = 0,\n  align,\n  alignOffset = 0,\n  shouldAvoidCollisions = true,\n  collisionBoundariesRect,\n  collisionTolerance = 0,\n}: GetPlacementDataOptions): PlacementData {\n  // if we're not ready to do all the measurements yet,\n  // we return some good default styles\n  if (!anchorRect || !popperSize || !collisionBoundariesRect) {\n    return {\n      popperStyles: UNMEASURED_POPPER_STYLES,\n      arrowStyles: UNMEASURED_ARROW_STYLES,\n    };\n  }\n\n  // pre-compute points for all potential placements\n  const allPlacementPoints = getAllPlacementPoints(\n    popperSize,\n    anchorRect,\n    sideOffset,\n    alignOffset,\n    arrowSize\n  );\n\n  // get point based on side / align\n  const popperPoint = allPlacementPoints[side][align];\n\n  // if we don't need to avoid collisions, we can stop here\n  if (shouldAvoidCollisions === false) {\n    const popperStyles = getPlacementStylesForPoint(popperPoint);\n\n    let arrowStyles = UNMEASURED_ARROW_STYLES;\n    if (arrowSize) {\n      arrowStyles = getPopperArrowStyles({ popperSize, arrowSize, arrowOffset, side, align });\n    }\n\n    const transformOrigin = getTransformOrigin(popperSize, side, align, arrowOffset, arrowSize);\n\n    return {\n      popperStyles: {\n        ...popperStyles,\n        ['--radix-popper-transform-origin' as any]: transformOrigin,\n      },\n      arrowStyles,\n      placedSide: side,\n      placedAlign: align,\n    };\n  }\n\n  // create a new rect as if element had been moved to new placement\n  const popperRect = DOMRect.fromRect({ ...popperSize, ...popperPoint });\n\n  // create a new rect representing the collision boundaries but taking into account any added tolerance\n  const collisionBoundariesRectWithTolerance = getContractedRect(\n    collisionBoundariesRect,\n    collisionTolerance\n  );\n\n  // check for any collisions in new placement\n  const popperCollisions = getCollisions(popperRect, collisionBoundariesRectWithTolerance);\n\n  // do all the same calculations for the opposite side\n  // this is because we need to check for potential collisions if we were to swap side\n  const oppositeSide = getOppositeSide(side);\n  const oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];\n  const updatedOppositeSidePopperPoint = DOMRect.fromRect({\n    ...popperSize,\n    ...oppositeSidePopperPoint,\n  });\n  const oppositeSidePopperCollisions = getCollisions(\n    updatedOppositeSidePopperPoint,\n    collisionBoundariesRectWithTolerance\n  );\n\n  // adjust side accounting for collisions / opposite side collisions\n  const placedSide = getSideAccountingForCollisions(\n    side,\n    popperCollisions,\n    oppositeSidePopperCollisions\n  );\n\n  // adjust alignnment accounting for collisions\n  const placedAlign = getAlignAccountingForCollisions(\n    popperSize,\n    anchorRect,\n    side,\n    align,\n    popperCollisions\n  );\n\n  const placedPopperPoint = allPlacementPoints[placedSide][placedAlign];\n\n  // compute adjusted popper / arrow styles\n  const popperStyles = getPlacementStylesForPoint(placedPopperPoint);\n\n  let arrowStyles = UNMEASURED_ARROW_STYLES;\n  if (arrowSize) {\n    arrowStyles = getPopperArrowStyles({\n      popperSize,\n      arrowSize,\n      arrowOffset,\n      side: placedSide,\n      align: placedAlign,\n    });\n  }\n\n  const transformOrigin = getTransformOrigin(\n    popperSize,\n    placedSide,\n    placedAlign,\n    arrowOffset,\n    arrowSize\n  );\n\n  return {\n    popperStyles: {\n      ...popperStyles,\n      ['--radix-popper-transform-origin' as any]: transformOrigin,\n    },\n    arrowStyles,\n    placedSide,\n    placedAlign,\n  };\n}\n\ntype AllPlacementPoints = Record<Side, Record<Align, Point>>;\n\nfunction getAllPlacementPoints(\n  popperSize: Size,\n  anchorRect: ClientRect,\n  sideOffset: number = 0,\n  alignOffset: number = 0,\n  arrowSize?: Size\n): AllPlacementPoints {\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n\n  const x = getPopperSlotsForAxis(anchorRect, popperSize, 'x');\n  const y = getPopperSlotsForAxis(anchorRect, popperSize, 'y');\n\n  const topY    = y.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const bottomY = y.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n  const leftX   = x.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const rightX  = x.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n\n  // prettier-ignore\n  const map: AllPlacementPoints = {\n    top: {\n      start:  { x: x.start + alignOffset, y: topY },\n      center: { x: x.center,              y: topY },\n      end:    { x: x.end - alignOffset,   y: topY },\n    },\n    right: {\n      start:  { x: rightX, y: y.start + alignOffset },\n      center: { x: rightX, y: y.center },\n      end:    { x: rightX, y: y.end - alignOffset },\n    },\n    bottom: {\n      start:  { x: x.start + alignOffset, y: bottomY },\n      center: { x: x.center,              y: bottomY },\n      end:    { x: x.end - alignOffset,   y: bottomY },\n    },\n    left: {\n      start:  { x: leftX, y: y.start + alignOffset },\n      center: { x: leftX, y: y.center },\n      end:    { x: leftX, y: y.end - alignOffset },\n    },\n  };\n\n  return map;\n}\n\nfunction getPopperSlotsForAxis(anchorRect: ClientRect, popperSize: Size, axis: Axis) {\n  const startSide = axis === 'x' ? 'left' : 'top';\n  const anchorStart = anchorRect[startSide];\n\n  const dimension = axis === 'x' ? 'width' : 'height';\n  const anchorDimension = anchorRect[dimension];\n  const popperDimension = popperSize[dimension];\n\n  // prettier-ignore\n  return {\n    before: anchorStart - popperDimension,\n    start:  anchorStart,\n    center: anchorStart + (anchorDimension - popperDimension) / 2,\n    end:    anchorStart + anchorDimension - popperDimension,\n    after:  anchorStart + anchorDimension,\n  };\n}\n\n/**\n * Gets an adjusted side based on collision information\n */\nfunction getSideAccountingForCollisions(\n  /** The side we want to ideally position to */\n  side: Side,\n  /** The collisions for this given side */\n  collisions: Collisions,\n  /** The collisions for the opposite side (if we were to swap side) */\n  oppositeSideCollisions: Collisions\n): Side {\n  const oppositeSide = getOppositeSide(side);\n  // in order to prevent premature jumps\n  // we only swap side if there's enough space to fit on the opposite side\n  return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;\n}\n\n/**\n * Gets an adjusted alignment based on collision information\n */\nfunction getAlignAccountingForCollisions(\n  /** The size of the popper to place */\n  popperSize: Size,\n  /** The size of the anchor we are placing around */\n  anchorSize: Size,\n  /** The final side */\n  side: Side,\n  /** The desired align */\n  align: Align,\n  /** The collisions */\n  collisions: Collisions\n): Align {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n  const startBound = isHorizontalSide ? 'left' : 'top';\n  const endBound = isHorizontalSide ? 'right' : 'bottom';\n  const dimension = isHorizontalSide ? 'width' : 'height';\n  const isAnchorBigger = anchorSize[dimension] > popperSize[dimension];\n\n  if (align === 'start' || align === 'center') {\n    if ((collisions[startBound] && isAnchorBigger) || (collisions[endBound] && !isAnchorBigger)) {\n      return 'end';\n    }\n  }\n\n  if (align === 'end' || align === 'center') {\n    if ((collisions[endBound] && isAnchorBigger) || (collisions[startBound] && !isAnchorBigger)) {\n      return 'start';\n    }\n  }\n\n  return align;\n}\n\nfunction getPlacementStylesForPoint(point: Point): CSS.Properties {\n  const x = Math.round(point.x + window.scrollX);\n  const y = Math.round(point.y + window.scrollY);\n  return {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    minWidth: 'max-content',\n    willChange: 'transform',\n    transform: `translate3d(${x}px, ${y}px, 0)`,\n  };\n}\n\nfunction getTransformOrigin(\n  popperSize: Size,\n  side: Side,\n  align: Align,\n  arrowOffset: number,\n  arrowSize?: Size\n): CSS.Properties['transformOrigin'] {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n\n  const arrowBaseLength = arrowSize ? arrowSize.width : 0;\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n  const sideOffset = arrowBaseToTipLength;\n  const alignOffset = arrowBaseLength / 2 + arrowOffset;\n\n  let x = '';\n  let y = '';\n\n  if (isHorizontalSide) {\n    x = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.width - alignOffset}px`,\n    }[align];\n\n    y = side === 'top' ? `${popperSize.height + sideOffset}px` : `${-sideOffset}px`;\n  } else {\n    x = side === 'left' ? `${popperSize.width + sideOffset}px` : `${-sideOffset}px`;\n\n    y = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.height - alignOffset}px`,\n    }[align];\n  }\n\n  return `${x} ${y}`;\n}\n\nconst UNMEASURED_POPPER_STYLES: CSS.Properties = {\n  // position: 'fixed' here is important because it will take the popper\n  // out of the flow so it does not disturb the position of the anchor\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  opacity: 0,\n  transform: 'translate3d(0, -200%, 0)',\n};\n\nconst UNMEASURED_ARROW_STYLES: CSS.Properties = {\n  // given the arrow is nested inside the popper,\n  // make sure that it is out of the flow and doesn't hinder then popper's measurement\n  position: 'absolute',\n  opacity: 0,\n};\n\ntype GetArrowStylesOptions = {\n  /** The size of the popper to place */\n  popperSize: Size;\n  /** The size of the arrow itself */\n  arrowSize: Size;\n  /** An offset for the arrow along the align axis */\n  arrowOffset: number;\n  /** The side where the arrow points to */\n  side: Side;\n  /** The alignment of the arrow along the side */\n  align: Align;\n};\n\n/**\n * Computes the styles necessary to position, rotate and align the arrow correctly.\n * It can adjust itself based on anchor/popper size, side/align and an optional offset.\n */\nfunction getPopperArrowStyles({\n  popperSize,\n  arrowSize,\n  arrowOffset,\n  side,\n  align,\n}: GetArrowStylesOptions): CSS.Properties {\n  const popperCenterX = (popperSize.width - arrowSize.width) / 2;\n  const popperCenterY = (popperSize.height - arrowSize.width) / 2;\n\n  const rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };\n  const rotation = rotationMap[side];\n  const arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);\n\n  const styles: CSS.Properties = {\n    // we make sure we put the arrow inside a 1:1 ratio container\n    // this is to make the rotation handling simpler\n    // as we do no need to worry about changing the transform-origin\n    width: `${arrowMaxDimension}px`,\n    height: `${arrowMaxDimension}px`,\n\n    // rotate the arrow appropriately\n    transform: `rotate(${rotation}deg)`,\n    willChange: 'transform',\n\n    // position the arrow appropriately\n    position: 'absolute',\n    [side]: '100%',\n\n    // Because the arrow gets rotated (see `transform above`)\n    // and we are putting it inside a 1:1 ratio container\n    // we need to adjust the CSS direction from `ltr` to `rtl`\n    // in some circumstances\n    direction: getArrowCssDirection(side, align),\n  };\n\n  if (side === 'top' || side === 'bottom') {\n    if (align === 'start') {\n      styles.left = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.left = `${popperCenterX}px`;\n    }\n    if (align === 'end') {\n      styles.right = `${arrowOffset}px`;\n    }\n  }\n\n  if (side === 'left' || side === 'right') {\n    if (align === 'start') {\n      styles.top = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.top = `${popperCenterY}px`;\n    }\n    if (align === 'end') {\n      styles.bottom = `${arrowOffset}px`;\n    }\n  }\n\n  return styles;\n}\n\n/**\n * Adjusts the arrow's CSS direction (`ltr` / `rtl`)\n */\nfunction getArrowCssDirection(side: Side, align: Align): CSS.Property.Direction {\n  if ((side === 'top' || side === 'right') && align === 'end') {\n    return 'rtl';\n  }\n\n  if ((side === 'bottom' || side === 'left') && align !== 'end') {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n\n/**\n * Gets the opposite side of a given side (ie. top => bottom, left => right, â€¦)\n */\nfunction getOppositeSide(side: Side): Side {\n  const oppositeSides: Record<Side, Side> = {\n    top: 'bottom',\n    right: 'left',\n    bottom: 'top',\n    left: 'right',\n  };\n  return oppositeSides[side];\n}\n\n/**\n * Creates a new rect (`ClientRect`) based on a given one but contracted by\n * a given amout on each side.\n */\nfunction getContractedRect(rect: ClientRect, amount: number) {\n  return DOMRect.fromRect({\n    width: rect.width - amount * 2,\n    height: rect.height - amount * 2,\n    x: rect.left + amount,\n    y: rect.top + amount,\n  });\n}\n\n/**\n * Gets collisions for each side of a rect (top, right, bottom, left)\n */\nfunction getCollisions(\n  /** The rect to test collisions against */\n  rect: ClientRect,\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect: ClientRect\n) {\n  return {\n    top: rect.top < collisionBoundariesRect.top,\n    right: rect.right > collisionBoundariesRect.right,\n    bottom: rect.bottom > collisionBoundariesRect.bottom,\n    left: rect.left < collisionBoundariesRect.left,\n  };\n}\n\ntype Collisions = ReturnType<typeof getCollisions>;\n\nexport { getPlacementData, SIDE_OPTIONS, ALIGN_OPTIONS };\nexport type { Side, Align };\n"]},"metadata":{},"sourceType":"module"}